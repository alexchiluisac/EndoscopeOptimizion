%% This script generates data to help decide how many points should be generated with RRT
clc, clear, close all

fprintf('*** Determine the optimal points to be sampled with RRT *** \n');
fprintf('This procedure runs RRT multiple times, each time sampling a different number of points,\n');
fprintf('in an attempt to determine the optimal numer of points to be used.\n');

% add dependencies
addpath('kinematics')
addpath('path-planning')
addpath('utils')
addpath('utils/ray-casting/')
addpath('../anatomical-models')

% define the robot's range of motion
maxDisplacement = 1; % [mm]
maxRotation     = 2*pi; % [rad]
maxAdvancement  = 10; % [mm]

% Load cavity model
path = fullfile('..', 'anatomical-models', 'synthetic-model.stl');
[vertices, faces, ~, ~] = stlRead(path);
earModel.vertices = vertices;
earModel.faces = faces;

% Calculate the base transform for the robot
t = [30 8 10];
R = [0 0 -1; 0 1 0; 1 0 0];
T = [R t'; 0 0 0 1];
earModel.baseTransform = T;

% Create a robot
alpha = 0;
cutouts = [];
cutouts.w = [1 1 1 1 1 1];
cutouts.u = [1 1 1 1 1 1];
cutouts.h = [1 1 1 1 1 1];
cutouts.alpha = [0 0 0 alpha 0 0];

robot = Wrist(1.6, 1.85, 4, cutouts);

% Run RRT to estimate the reachable workspace of the robot
nPoints = [50 50 50 50 50 50];

% Initialize data variables to store the results
reachableWorkspace = {};
reachableWorkspaceVolume = zeros(1, length(nPoints));
pointsCount = zeros(1, length(nPoints));
qListNormalized = {};
qList = {};
pList = {};
aList = {};

parfor jj = 1 : length(nPoints)
    [qListNormalized{jj},qList{jj},pList{jj},aList{jj}] = rrt(robot, ...
        [maxDisplacement maxRotation maxAdvancement], ...
        earModel, ...
        nPoints(jj));
    
    reachableWorkspace{jj}.vertices = pList{jj}';
    
    % Estimate the reachable workspace
    shrinkFactor = 1;
    [reachableWorkspace{jj}.faces, reachableWorkspaceVolume(jj)] = ...
       boundary(pList{jj}(1,:)', pList{jj}(2,:)', pList{jj}(3,:)', shrinkFactor);
    
    pointsCount(jj) = length(pList{jj});
end

% Plot the results
figure, subplot(2,3,1);

for ii = 1 : length(nPoints)
    subplot(2,3,ii);
    
    trisurf(reachableWorkspace{ii}.faces, ...
        reachableWorkspace{ii}.vertices(:,1), ...
        reachableWorkspace{ii}.vertices(:,2), ...
        reachableWorkspace{ii}.vertices(:,3), ...
        'Facecolor','red','FaceAlpha',0.1);
    
    axis equal;
    xlabel('X [mm]'), ylabel('Y [mm]'), zlabel('Z [mm]');
    xlim([10 30]), ylim([5 14]), zlim([5 15])
    
    title(['nPoints = ' num2str(pointsCount(ii))]);
end

figure
scatter(pointsCount, reachableWorkspaceVolume, 'o', 'filled', 'red');
xlabel('Total number of points generated by RRT'), ylabel('Volume of reachable workspace [mm^3]');
grid on

% !FIXME implement search for optimal number of points
mdl = fitlm(reachableWorkspaceVolume, pointsCount);
b = mdl.Coefficients.Estimate(1);
a = mdl.Coefficients.Estimate(2);

fprintf();